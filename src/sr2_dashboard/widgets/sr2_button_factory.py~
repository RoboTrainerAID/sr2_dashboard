class SR2ButtonWidgetFactory:

    class ButtonWidget(QWidget):
        """
        A widget with a button controlling a single process (in case of roslaunch it controlls
        indirectly all processes that were spawned by that command due to the nature of roslaunch)
        """

        @staticmethod
        def check_pid(pid):
            ''' Checks if a process with a given PID is running or not'''
            try:
                kill(pid, 0)
                return True
            except OSError:
                return False

        def onResize(self, event):
            ''' Called whenever a resize event is triggered on the widget. It resizes the icon (if present) inside the button'''
            if self.icons != None:
                self.qbtn.setIconSize(QSize(self.qbtn.width()/2, self.qbtn.height()/2))

            #if self.caption != None:
            #  font = self.font()yamlButtonList[ybutton]
            #  font.setPixelSize(self.qbtn.height()/4)
            #  self.setFont(font)

        def __init__(self, pkg, cmd, args, captions, icons=None):
            super(SR2DashboardItemFactory.SR2MenuView.SR2ButtonWidgetFactory.ButtonWidget, self).__init__()
            QWidget.__init__(self)

            print("Generating button")
            self.captions = captions
            self.icons = icons
            self.command = cmd
            self.args = args
            self.status = False
            self.pkg = pkg
            self.pid = 0

            # A PID file is used for storage of the detached process
            # In case the UI crashes or is closed intentionally this
            # file is used to restore the UI's state and reconnect it
            # to the detached processes so that these can be controlled
            # The format of a PID file for now is as follows:
            # rosrun:       rospkg + '_' + 'rosrun' + '_' + 'nodeName' + '.pid'
            # roslaunch:    rospkg + '_' + 'roslaunch' + '_' + 'launchFile1' + '_' + 'launchFile2' + '_' + ... + '.pid'
            # PID files are written to the .pid folder inside the folder where the executable is (in order to avoid the "Woops, I deleted this PID file by accident..." error)
            if not exists('.pid'):
                print("Creating hidden folder '.pid' for storing PID files")
                mkdir('.pid')

            # Only in case we have multiple launch files (determined by the spaces between the names of the files contained in the self.args string) we remove the spaces
#                    self.pidFilePath =  '.pid/'
#                                        + self.pkg
#                                        + '_'
#                                        + self.command
#                                        + '_'
#                                        + (self.args if ' ' in self.args == True else "".join(self.args.split()))
            arg2str = ''
            for i in range(0, len(self.args)):
                arg2str = arg2str + self.args[i]
            self.pidFilePath =  '.pid/%s_%s_%s.pid' % (self.pkg, self.command, arg2str)
            print('PID file: "' + self.pidFilePath + '"')

            if isfile(self.pidFilePath):
                with open(self.pidFilePath) as pidF:
                    self.pid = int(pidF.readline())
                    print('Found "' + self.pidFilePath + '". Restoring connection to detached process with PID' + str(self.pid))
                    self.status = True
            else:
                print('Warning: No "' + self.pidFilePath + '" detected. If you have started the detached process, closed the UI and deleted this file, the application will be unable to restore its state and the external process will be orphaned!')

            # TODO Rewrite where necessary initUI and toggleProcess in order to included the three possible states for a button: default(=not pressed), pressed and warning (icon and caption for each of those states is provided by the YAML config file!)
            self.initUi()

        def initUi(self):
            '''
            Creates a simply UI for the widget with a single button in it
            For the functionality behind the button see toggleProcess()
            '''
            self.hbox = QHBoxLayout()
#            if len(self.caption) != 0:
#                self.qbtn = QPushButton('Start \"' + self.caption + '\"', self)
#            else:
#                self.qbtn = QPushButton(self)
#            if self.icon != None:
#                self.qbtn.setIcon(QIcon(self.icon))

            # Sometimes Qt is full of ****. Why is it so hard to place an icon in the center of a button
            # and the text aligned at the bottom of that button?!?!?!?!?!?!
            # Result below looks bad but not as bad as using the default QPushbutton where text is aligned to the right
            # of the icon.  Resizing text accordingly is also hard
            # These two things are even more difficult to do when working with a grid layout!
            self.qbtn = QToolButton(self)
            self.qbtn.setText(self.captions[0])
            self.qbtn.setIcon(QIcon(self.icons[0]))
            self.qbtn.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)
#                    self.qbtn.setStyleSheet('''
#                    QToolButton {
#                        background: url(flaticon_Freepik_delete30.svg) top center no-repeat;
#                        padding-top: 32px;
#                    }
#                    ''')
#

            self.qbtn.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            self.qbtn.setCheckable(True)
            self.qbtn.resizeEvent = self.onResize

            if self.status:
                self.qbtn.setChecked(True)
                self.qbtn.setText(self.captions[1])
                self.qbtn.setIcon(QIcon(self.icons[1]))

            self.qbtn.clicked.connect(self.toggleProcess)
            self.qbtn.resize(self.qbtn.sizeHint())
            self.hbox.addWidget(self.qbtn)
            self.setLayout(self.hbox)
            self.setGeometry(300, 300, 250, 150)
            self.show()

        def broadcastedStop(self):
            rospy.loginfo("Stop signal")
            self.toggleProcess(False)

        def toggleProcess(self, val):
            ''' Controls a process (on/off states only) that is controlled by the button calling it
                It also stores the PID of the process inside a special PID file (*.pid), which is used
                in the recovery mechanism of the UI in a case of an UI crash or deliberate termination'''
            # If button pressed
            if val:
                print('SR2: Starting process for command "%s" with arguments:' % self.command) #self.pkg CONCAT with self.args
                print(self.pkg,self.args)
        		# Note: when roslaunch is terminated all processes spawned by it are also terminated
        		# thus even if roscore has been started by the roslaunch process it will too be stopped :)
              # Note that all arguments (including package name) have to be inside a list of strings
                self.status, self.pid = QProcess.startDetached(self.command, [self.pkg] + self.args, '.')
                if self.status:
                    # Change to pressed state
                    print('SR2: PID:' + str(self.pid))
                    pidFile = open(self.pidFilePath, 'w')
                    pidFile.write(str(self.pid))
                    pidFile.close()
                    self.qbtn.setText(self.captions[1])
                    self.qbtn.setIcon(QIcon(self.icons[1]))
                else:
                    self.qbtn.setChecked(False)
                    # Change to warning state
                    self.qbtn.setText(self.captions[2])
                    self.qbtn.setIcon(QIcon(self.icons[2]))
                    rospy.logerr('SR2: Failed to start process')
            else:
                print('SR2: Stopping process')
                if self.status:
                    # kill takes a very short amount of time hence we can call it from inside the main thread without freezing the UI
                    self.success = None
                    # WARNING: ROS documentation states that "rosnode kill" is not guaranteed to succeed
                    # especially when the node that is to be killed has its "respawn" property on hence
                    # we use the kill command with SIGINT signal for both cases - roslaunch and rosrun

                    # OLD VERSION
                    '''if self.command == 'rosrun':
                        self.success = subprocess.call(['rosnode', 'kill', self.args[-1]]) # the last element of the list with args (only when a node is started with rosrun!) is the name of the node
                        # Dang it, "rosnode kill" sucks!
                    else:
                        if SR2ButtonWidgetFactory.ButtonWidget.check_pid(self.pid):
                            self.success = kill(self.pid, SIGINT)
                        else:
                            print 'Error: No process with PID ' + str(self.pid) + ' detected'
                            if isfile(self.pidFilePath):
                                remove(self.pidFilePath)'''
                    if SR2DashboardItemFactory.SR2MenuView.SR2ButtonWidgetFactory.ButtonWidget.check_pid(self.pid):
                        self.success = kill(self.pid, SIGINT)
                    else:
                        rospy.logerr('SR2: No process with PID ' + str(self.pid) + ' detected')
                        if isfile(self.pidFilePath):
                            remove(self.pidFilePath)

                    # NOTE: using scripts (rosrun pkg_name script.py) and not launching ROS-confrom nodes creates
                    # nodes like "talker_121314_12121414", which are impossible to distinguish without too much
                    # fuss and make it really difficult to use 'rosnode kill' hence the requirement to start only
                    # nodes that have a simple, distinguishable name so that rosnode kill can be used or use roslaunch
                    # and launch files to give proper names
                    # == 0 : for subprocess.call() return value | == None : for os.kill() return value (None -> kill was successful)
                    if self.success == 0 or self.success == None:
                        rospy.loginfo("SR2: Process stopped!")
                        self.status = False
                        self.pid = 0
                        if isfile(self.pidFilePath):
                            remove(self.pidFilePath)
                        self.qbtn.setText(self.captions[0])
                        self.qbtn.setIcon(QIcon(self.icons[0]))
                    else:
                        self.qbtn.setChecked(True)
                        self.qbtn.setText(self.captions[2])
                        self.qbtn.setIcon(QIcon(self.icons[2]))
                        rospy.logerr('SR2: Failed to stop process')

        @staticmethod
        def createButtonWidget(yamlButtonConfig):
            """
            Creates a QWidget with a button inside that is used to start/stop a given process
            A button configuration is a dictionary with following keys:
            - caption: the string that will be used to label the button
            - icon (optional): a valid path to an image file (SVG, PNG etc. - all supported format by Qt)
            - rospkg:  a valid ROS package
            - command:    the type of command for 'target'; can be 'roslaunch' or 'rosrun'
            - target:  the target to be executed:
                - for a 'roslaunch' command: a list of valid ROS launch files within the selected 'rospkg'
                  ['file1.launch', 'file2.launch', ...]
                - for a 'rosrun' command: name of a valid ROS node
            - action: reference to a function based on rospkg, command and target; it is the functionality that the
                      created button will offer once inserted in the GUI
            """

            print('SR2: parsing button configuration', yamlButtonConfig)
            assert yamlButtonConfig != None, "Empty button configuration"

            pkg = ''
            cmd = ''
            args = []
            # Try each of the possible configurations: node, launch and service
            # TODO Check if launch files etc exist or always launch the chosen command and let it fail if these are not present (let ROS handle the search for the files)
            try:
                pkg = yamlButtonConfig['package']
                rospy.loginfo('Using package %s' % pkg)
                try:
                    args = yamlButtonConfig['node']
                    rospy.loginfo('Nodes detected. Will use "rosrun"')
                    cmd = 'rosrun'

                except KeyError:
                    try:
                        _args = yamlButtonConfig['launch']
                        rospy.loginfo('Launch file(s) detected. Will use "roslaunch"')
                        cmd = 'roslaunch'

                        args.append(_args + '.launch')
                        rospy.loginfo('Single launch file detected: "%s"' % args)

                    except KeyError:
                        try:
                            args.append(yamlButtonConfig['serivce'])
                            rospy.loginfo('Service deteceted. Will use "rosservice call"')
                            cmd = 'rosservice call'

                        except KeyError as exc:
                            rospy.logerror('Button does not contain data that can be executed by the supported ROS tools. Add node, launch or service to the button"s description')
                            raise exc

                captions = []
                captions.append(yamlButtonConfig['captions']['default'])
                captions.append(yamlButtonConfig['captions']['pressed'])
                captions.append(yamlButtonConfig['captions']['warning'])

                #icon_paths = (icon_paths if icon_paths else []) + [['sr2_dashboard', 'resources/images']]
                icons = []
#                        for path in icon_paths:
#                            paths.append(os.path.join(rp.get_path(path[0]), path[1]))
#                        _icon_helper = IconHelper(paths, name)
#                        converted_icons = self._icon_helper.set_icon_lists(icons)
#                        _icons = converted_icons[0]
                # TODO Use the IconHelper to populate the icons list using the names of the
                icons.append(yamlButtonConfig['icons']['default'])
                icons.append(yamlButtonConfig['icons']['pressed'])
                icons.append(yamlButtonConfig['icons']['warning'])

            except KeyError as exc:
                rospy.loginfo('SR2: error while loading YAML file.')
                rospy.loginfo('SR2: full message: \n"%s"' % exc)
                return None

            #return SR2DashboardItemFactory.SR2MenuView.SR2ButtonWidgetFactory.ButtonWidget(yamlButtonConfig['caption'], yamlButtonConfig['rospkg'], yamlButtonConfig['roscommand'], yamlButtonConfig['target'], yamlButtonConfig['icon'])
            return SR2DashboardItemFactory.SR2MenuView.SR2ButtonWidgetFactory.ButtonWidget(pkg, cmd, args, captions, icons)


